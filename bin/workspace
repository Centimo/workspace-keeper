#!/bin/bash
# Workspace manager: creates KDE virtual desktops with CLion + WezTerm + Floorp
#
# Usage:
#   workspace create <path> [name]  — create or switch to workspace
#   workspace save [name]           — save Floorp tabs for current workspace
#   workspace close [name]          — save tabs and remove workspace
#   workspace pin                   — pin focused Floorp window to all desktops
#   workspace list                  — list workspaces
#   workspace menu                  — rofi popup to switch/create/close workspaces
#   workspace handle-response "<r>"  — handle daemon menu response directly

set -euo pipefail

_START_MS=$(date +%s%3N)
WORKSPACE_DIR="$HOME/.config/workspaces"
mkdir -p "$WORKSPACE_DIR"

log() {
  local msg="$1"
  local ts
  ts=$(date '+%H:%M:%S.%3N')
  echo "[$ts] $msg" >&2
  logger -t workspace --id=$$ -- "$msg"
}

get_current_desktop_name() {
  wmctrl -d | awk '$2 == "*" {
    for(i=NF; i>0; i--) {
      if ($i ~ /^[0-9]+x[0-9]+$/) { break }
    }
    result=""
    for(j=i+1; j<=NF; j++) result = result (j>i+1 ? " " : "") $j
    print result
  }'
}

get_desktop_index() {
  local name="$1"
  wmctrl -d | while IFS= read -r line; do
    local idx dname
    idx=$(echo "$line" | awk '{print $1}')
    dname=$(echo "$line" | awk '{
      for(i=NF; i>0; i--) {
        if ($i ~ /^[0-9]+x[0-9]+$/) break
      }
      result=""
      for(j=i+1; j<=NF; j++) result = result (j>i+1 ? " " : "") $j
      print result
    }')
    if [[ "$dname" == "$name" ]]; then
      echo "$idx"
      return 0
    fi
  done
}

get_desktop_id_by_name() {
  local name="$1"
  qdbus --literal org.kde.KWin /VirtualDesktopManager desktops 2>/dev/null \
    | grep -oP '"[a-f0-9A-F-]+", "'"$name"'"' \
    | grep -oP '"[a-f0-9A-F-]+"' | head -1 | tr -d '"'
}

create_desktop() {
  local position="$1"
  local name="$2"
  local before
  before=$(qdbus --literal org.kde.KWin /VirtualDesktopManager desktops 2>/dev/null \
    | grep -oP '"[a-f0-9A-F-]+"' | sort)
  qdbus org.kde.KWin /VirtualDesktopManager createDesktop "$position" "$name"
  sleep 0.3
  local after
  after=$(qdbus --literal org.kde.KWin /VirtualDesktopManager desktops 2>/dev/null \
    | grep -oP '"[a-f0-9A-F-]+"' | sort)
  comm -13 <(echo "$before") <(echo "$after") | head -1
}

# Move window to desktop via KWin scripting API.
# KWin updates _NET_WM_DESKTOP itself after client.desktop assignment —
# no need for separate wmctrl -t (which can race with KWin).
# Uses clientAdded callback to handle windows not yet in clientList().
# $1 — X11 window ID (hex, e.g. 0x05a958cd)
# $2 — desktop index (0-based, as wmctrl uses)
kwin_move_to_desktop() {
  local hex_wid="$1"
  local desktop_idx="$2"
  local dec_wid=$(( hex_wid ))
  local kwin_desktop=$(( desktop_idx + 1 ))

  log "move wid=$hex_wid (dec=$dec_wid) to desktop=$desktop_idx (kwin=$kwin_desktop)"

  local script="/tmp/kwin-move-$$.js"
  cat > "$script" << JSEOF
(function() {
  function moveWindow(client) {
    if (client.windowId === ${dec_wid}) {
      client.desktop = ${kwin_desktop};
      return true;
    }
    return false;
  }

  var clients = workspace.clientList();
  for (var i = 0; i < clients.length; i++) {
    if (moveWindow(clients[i])) return;
  }

  // Window not found yet — wait for it via signal
  var handler = function(client) {
    if (moveWindow(client)) {
      workspace.clientAdded.disconnect(handler);
    }
  };
  workspace.clientAdded.connect(handler);
})();
JSEOF

  local script_name="workspace-move-$$"
  qdbus org.kde.KWin /Scripting unloadScript "$script_name" 2>/dev/null || true
  qdbus org.kde.KWin /Scripting loadScript "$script" "$script_name" >/dev/null
  qdbus org.kde.KWin /Scripting start >/dev/null

  sleep 0.5

  # Verify move succeeded by checking _NET_WM_DESKTOP
  local actual_desktop
  actual_desktop=$(xprop -id "$hex_wid" _NET_WM_DESKTOP 2>/dev/null \
    | awk '{print $NF}') || true
  if [[ "$actual_desktop" != "$desktop_idx" ]]; then
    log "move verify: expected desktop=$desktop_idx, got=$actual_desktop — waiting longer"
    sleep 1
    actual_desktop=$(xprop -id "$hex_wid" _NET_WM_DESKTOP 2>/dev/null \
      | awk '{print $NF}') || true
  fi

  log "move result: wid=$hex_wid _NET_WM_DESKTOP=$actual_desktop"

  qdbus org.kde.KWin /Scripting unloadScript "$script_name" 2>/dev/null || true
  rm -f "$script"
}

# Force _NET_WM_DESKTOP re-sync for windows on desktops above the removed one.
# KWin bug: removeDesktop shifts internal numbering but doesn't update X11 property.
# Bounce (desktop=other, desktop=original) forces KWin to re-write _NET_WM_DESKTOP.
# $1 — removed desktop index (0-based)
kwin_resync_desktops_above() {
  local removed_idx="$1"
  local removed_kwin=$((removed_idx + 1))  # KWin 1-based

  log "resync: bouncing windows on desktops above removed index $removed_idx"

  local script="/tmp/kwin-resync-$$.js"
  cat > "$script" << JSEOF
(function() {
  var clients = workspace.clientList();
  for (var i = 0; i < clients.length; i++) {
    var c = clients[i];
    if (c.desktop < ${removed_kwin} || c.desktop < 1) continue;

    // Bounce to a different desktop and back to force _NET_WM_DESKTOP update.
    // Use desktop +1 or -1 to avoid flicker on current desktop.
    var d = c.desktop;
    var bounce = (d > 1) ? d - 1 : d + 1;
    c.desktop = bounce;
    c.desktop = d;
    print("resynced wid=" + c.windowId + " desktop=" + d);
  }
})();
JSEOF

  local script_name="workspace-resync-$$"
  qdbus org.kde.KWin /Scripting unloadScript "$script_name" 2>/dev/null || true
  qdbus org.kde.KWin /Scripting loadScript "$script" "$script_name" >/dev/null
  qdbus org.kde.KWin /Scripting start >/dev/null
  sleep 0.3
  qdbus org.kde.KWin /Scripting unloadScript "$script_name" 2>/dev/null || true
  rm -f "$script"

  log "resync: done"
}

find_bt_window_for_x_window() {
  local x_wid="$1"
  local x_title
  x_title=$(xprop -id "$x_wid" _NET_WM_NAME 2>/dev/null \
    | sed 's/_NET_WM_NAME(UTF8_STRING) = "\(.*\)"/\1/' \
    | sed 's/ — Ablaze Floorp$//')

  if [[ -z "$x_title" ]]; then
    return 1
  fi

  local bt_output
  bt_output=$(bt list 2>/dev/null) || return 1

  local bt_wins
  bt_wins=$(bt windows 2>/dev/null | awk -F'\t' '{print $1}') || return 1

  while IFS= read -r bt_wid; do
    [[ -z "$bt_wid" ]] && continue
    if echo "$bt_output" | grep "^${bt_wid}\." | awk -F'\t' '{print $2}' \
        | grep -qF "$x_title"; then
      echo "$bt_wid"
      return 0
    fi
  done <<< "$bt_wins"
  return 1
}

workspace_has_wezterm_panes() {
  local ws_name="$1"
  wezterm cli list --format json 2>/dev/null \
    | jq -e --arg ws "$ws_name" '[.[] | select(.workspace == $ws)] | length > 0' \
    >/dev/null 2>&1
}

find_clion_window_for_project() {
  local project_dir="$1"
  wmctrl -l | grep -F "[$project_dir]" | awk '{print $1}' | head -1
}

find_floorp_on_desktop() {
  local desktop_idx="$1"
  wmctrl -l | awk -v d="$desktop_idx" '$2 == d && /Ablaze Floorp/ {print $1; exit}'
}

# Wait for a new window to appear (by diffing wmctrl -l).
# $1 — sorted list of window IDs before launch
# $2 — timeout in seconds
# $3 — optional regex to exclude (matched against window title)
wait_for_new_window() {
  local before="$1"
  local timeout="${2:-8}"
  local filter="${3:-}"

  log "waiting for new window (timeout=${timeout}s, filter='$filter')"
  local deadline=$((SECONDS + timeout))
  while (( SECONDS < deadline )); do
    local after
    after=$(wmctrl -l | awk '{print $1}' | sort)
    local new_wids
    new_wids=$(comm -13 <(echo "$before") <(echo "$after"))

    while IFS= read -r wid; do
      [[ -z "$wid" ]] && continue
      if [[ -n "$filter" ]]; then
        local title
        title=$(xprop -id "$wid" _NET_WM_NAME 2>/dev/null | sed 's/.*= "\(.*\)"/\1/' || true)
        if echo "$title" | grep -qiE "$filter"; then
          continue
        fi
      fi
      log "found new window $wid"
      echo "$wid"
      return 0
    done <<< "$new_wids"
    sleep 0.3
  done
  log "no new window found within ${timeout}s"
  return 1
}

cmd_create() {
  local project_dir="${1:?Usage: workspace create <path> [name]}"
  project_dir="$(realpath "$project_dir")"

  if [[ ! -d "$project_dir" ]]; then
    echo "Error: directory '$project_dir' does not exist" >&2
    exit 1
  fi

  local ws_name="${2:-$(basename "$project_dir")}"
  local ws_dir="$WORKSPACE_DIR/$ws_name"
  mkdir -p "$ws_dir"
  echo "$project_dir" > "$ws_dir/project_dir"

  log "create workspace '$ws_name' for $project_dir"

  # Check if this workspace desktop already exists — just switch to it
  local existing_idx
  existing_idx=$(get_desktop_index "$ws_name") || true
  if [[ -n "$existing_idx" ]]; then
    echo "Workspace '$ws_name' already active, switching..."
    wmctrl -s "$existing_idx"
    return 0
  fi

  # Create new virtual desktop
  local desktop_count
  desktop_count=$(qdbus org.kde.KWin /VirtualDesktopManager count)
  local desktop_id
  desktop_id=$(create_desktop "$desktop_count" "$ws_name")

  if [[ -z "$desktop_id" ]]; then
    echo "Error: failed to create desktop '$ws_name'" >&2
    exit 1
  fi

  local desktop_idx
  desktop_idx=$(get_desktop_index "$ws_name")
  if [[ -z "$desktop_idx" ]]; then
    echo "Error: could not find desktop index for '$ws_name'" >&2
    exit 1
  fi

  # Switch to new desktop FIRST — single-process apps (CLion, Floorp) create
  # windows on the current desktop, so we must be on the target desktop already.
  log "switching to desktop $desktop_idx"
  wmctrl -s "$desktop_idx"
  local switch_deadline=$((SECONDS + 3))
  while (( SECONDS < switch_deadline )); do
    local current
    current=$(wmctrl -d | awk '$2=="*" {print $1}')
    [[ "$current" == "$desktop_idx" ]] && break
    sleep 0.1
  done
  local current_desktop
  current_desktop=$(wmctrl -d | awk '$2=="*" {print $1}')
  if [[ "$current_desktop" != "$desktop_idx" ]]; then
    log "WARNING: desktop switch failed, expected=$desktop_idx current=$current_desktop"
    echo "Warning: desktop switch to $desktop_idx did not confirm (current=$current_desktop)" >&2
  else
    log "desktop switch confirmed"
  fi

  # --- WezTerm ---
  local before_wez
  before_wez=$(wmctrl -l | awk '{print $1}' | sort)

  if workspace_has_wezterm_panes "$ws_name"; then
    wezterm start --always-new-process --domain unix --workspace "$ws_name" --attach &
  else
    wezterm start --always-new-process --domain unix --workspace "$ws_name" --cwd "$project_dir" &
  fi

  local wez_wid
  wez_wid=$(wait_for_new_window "$before_wez" 8) || true
  if [[ -n "$wez_wid" ]]; then
    log "detected WezTerm window $wez_wid"
    kwin_move_to_desktop "$wez_wid" "$desktop_idx"
  else
    log "WezTerm window not detected"
    echo "Warning: WezTerm window not detected" >&2
  fi

  # --- CLion ---
  local clion_wid
  clion_wid=$(find_clion_window_for_project "$project_dir") || true
  if [[ -n "$clion_wid" ]]; then
    log "detected existing CLion window $clion_wid for $project_dir"
    kwin_move_to_desktop "$clion_wid" "$desktop_idx"
  else
    local before_clion
    before_clion=$(wmctrl -l | awk '{print $1}' | sort)

    "$HOME/.local/share/JetBrains/Toolbox/apps/clion/bin/clion" "$project_dir" &

    clion_wid=$(wait_for_new_window "$before_clion" 20 "Floorp") || true
    if [[ -n "$clion_wid" ]]; then
      log "detected new CLion window $clion_wid"
      kwin_move_to_desktop "$clion_wid" "$desktop_idx"
    else
      log "CLion window not detected"
      echo "Warning: CLion window not detected" >&2
    fi
  fi

  # --- Floorp ---
  local before_floorp
  before_floorp=$(wmctrl -l | awk '/Ablaze Floorp/ {print $1}' | sort)

  local tabs_file="$ws_dir/tabs.txt"
  if [[ -f "$tabs_file" ]] && [[ -s "$tabs_file" ]]; then
    floorp --new-window "$(head -1 "$tabs_file")" &
    sleep 1.5
    tail -n +2 "$tabs_file" | while IFS= read -r url; do
      [[ -z "$url" ]] && continue
      floorp --new-tab "$url" &
      sleep 0.15
    done
  else
    floorp --new-window "about:blank" &
  fi

  local floorp_wid=""
  local floorp_deadline=$((SECONDS + 8))
  while (( SECONDS < floorp_deadline )); do
    local after_floorp
    after_floorp=$(wmctrl -l | awk '/Ablaze Floorp/ {print $1}' | sort)
    floorp_wid=$(comm -13 <(echo "$before_floorp") <(echo "$after_floorp") | head -1)
    [[ -n "$floorp_wid" ]] && break
    sleep 0.3
  done
  if [[ -n "$floorp_wid" ]]; then
    log "detected Floorp window $floorp_wid"
    kwin_move_to_desktop "$floorp_wid" "$desktop_idx"
    # Tile to left half via KWin Quick Tile (like Meta+Left)
    wmctrl -i -a "$floorp_wid"
    sleep 0.3
    qdbus org.kde.kglobalaccel /component/kwin \
      org.kde.kglobalaccel.Component.invokeShortcut "Window Quick Tile Left"
  else
    log "Floorp window not detected"
    echo "Warning: Floorp window not detected" >&2
  fi

  log "workspace '$ws_name' created on desktop $desktop_idx"
  echo "Workspace '$ws_name' created"
  echo "  Project: $project_dir"
  echo "  Desktop: $desktop_idx"
}

cmd_save() {
  local ws_name="${1:-}"

  if [[ -z "$ws_name" ]]; then
    ws_name=$(get_current_desktop_name)
  fi

  local ws_dir="$WORKSPACE_DIR/$ws_name"
  if [[ ! -d "$ws_dir" ]]; then
    echo "Error: workspace '$ws_name' not found in $WORKSPACE_DIR" >&2
    exit 1
  fi

  local desktop_idx
  desktop_idx=$(get_desktop_index "$ws_name")
  if [[ -z "$desktop_idx" ]]; then
    echo "Error: desktop '$ws_name' not found" >&2
    exit 1
  fi

  local floorp_wid
  floorp_wid=$(find_floorp_on_desktop "$desktop_idx")
  if [[ -z "$floorp_wid" ]]; then
    echo "No Floorp window found on desktop '$ws_name'"
    return 0
  fi

  local bt_wid
  if ! bt_wid=$(find_bt_window_for_x_window "$floorp_wid"); then
    echo "Error: could not match Floorp window to BroTab window" >&2
    return 1
  fi

  if [[ -z "$bt_wid" ]]; then
    echo "Error: empty BroTab window ID" >&2
    return 1
  fi

  local tabs_file="$ws_dir/tabs.txt"
  bt list 2>/dev/null | grep "^${bt_wid}\." | awk -F'\t' '{print $3}' \
    | grep -v '^about:' > "$tabs_file"

  local count
  count=$(wc -l < "$tabs_file")
  echo "Saved $count tabs for workspace '$ws_name'"
}

cmd_close() {
  local ws_name="${1:-}"

  if [[ -z "$ws_name" ]]; then
    ws_name=$(get_current_desktop_name)
  fi

  # Save tabs first
  cmd_save "$ws_name" || echo "Warning: failed to save tabs for '$ws_name'" >&2

  local desktop_idx
  desktop_idx=$(get_desktop_index "$ws_name") || true

  local ws_dir="$WORKSPACE_DIR/$ws_name"

  # Close CLion window by matching project_dir in window title
  if [[ -f "$ws_dir/project_dir" ]]; then
    local project_dir
    project_dir=$(<"$ws_dir/project_dir")
    local clion_wid
    clion_wid=$(find_clion_window_for_project "$project_dir") || true
    if [[ -n "$clion_wid" ]]; then
      wmctrl -i -c "$clion_wid"
    fi
  fi

  # Close Floorp window on this desktop
  if [[ -n "$desktop_idx" ]]; then
    local floorp_wid
    floorp_wid=$(find_floorp_on_desktop "$desktop_idx")
    if [[ -n "$floorp_wid" ]]; then
      wmctrl -i -c "$floorp_wid"
    fi
  fi

  # Kill all panes of this workspace in mux-server.
  # GUI window closes automatically when no panes remain.
  local pane_ids
  pane_ids=$(wezterm cli list --format json 2>/dev/null \
    | jq -r --arg ws "$ws_name" '.[] | select(.workspace == $ws) | .pane_id')
  if [[ -n "$pane_ids" ]]; then
    while IFS= read -r pane_id; do
      wezterm cli kill-pane --pane-id "$pane_id" 2>/dev/null || true
    done <<< "$pane_ids"
  fi

  local desktop_id
  desktop_id=$(get_desktop_id_by_name "$ws_name")
  if [[ -n "$desktop_id" ]]; then
    qdbus org.kde.KWin /VirtualDesktopManager removeDesktop "$desktop_id"
    sleep 0.3

    # KWin bug: removeDesktop shifts KWin internal desktop numbers for windows
    # above the removed desktop, but does NOT update _NET_WM_DESKTOP X11 property.
    # Bounce all windows on affected desktops to force re-sync.
    if [[ -n "$desktop_idx" ]]; then
      kwin_resync_desktops_above "$desktop_idx"
    fi

    echo "Workspace '$ws_name' closed"
  else
    echo "Error: desktop '$ws_name' not found" >&2
    exit 1
  fi
}

cmd_pin() {
  local active_wid
  active_wid=$(xdotool getactivewindow 2>/dev/null) || {
    echo "Error: no active window" >&2
    exit 1
  }

  local wm_name
  wm_name=$(xprop -id "$active_wid" _NET_WM_NAME 2>/dev/null \
    | sed 's/_NET_WM_NAME(UTF8_STRING) = "\(.*\)"/\1/')

  if [[ "$wm_name" != *"Floorp"* ]] && [[ "$wm_name" != *"Ablaze Floorp"* ]]; then
    echo "Warning: active window doesn't look like Floorp ('$wm_name')"
    echo "Pinning anyway..."
  fi

  wmctrl -i -r "$active_wid" -b add,sticky
  echo "Pinned window '$wm_name' to all desktops"
}

cmd_list() {
  echo "Workspaces:"
  for ws in "$WORKSPACE_DIR"/*/; do
    [[ -d "$ws" ]] || continue
    local name project="" tabs=0 active=""
    name=$(basename "$ws")
    [[ -f "$ws/project_dir" ]] && project=$(cat "$ws/project_dir")
    [[ -f "$ws/tabs.txt" ]] && tabs=$(wc -l < "$ws/tabs.txt")
    local idx
    idx=$(get_desktop_index "$name") || true
    [[ -n "$idx" ]] && active=" [active]"
    echo "  $name  →  $project  ($tabs saved tabs)$active"
  done
}

cmd_handle_response() {
  local response="${1:?Usage: workspace handle-response \"<response>\"}"

  # Parse optional tab-separated restore window ID
  local restore_wid=""
  if [[ "$response" == *$'\t'* ]]; then
    restore_wid="${response##*$'\t'}"
    response="${response%%$'\t'*}"
  fi

  local action selected
  action="${response%% *}"
  selected="${response#* }"

  # No-op responses
  case "$action" in
    cancelled|busy|error) return 0 ;;
  esac

  [[ -z "$selected" ]] && return 0

  # Collect active desktops for handle logic
  declare -A active_desktops
  while IFS= read -r line; do
    local idx dname
    idx=$(printf '%s' "$line" | awk '{print $1}')
    dname=$(printf '%s' "$line" | awk '{
      for(i=NF; i>0; i--) {
        if ($i ~ /^[0-9]+x[0-9]+$/) break
      }
      result=""
      for(j=i+1; j<=NF; j++) result = result (j>i+1 ? " " : "") $j
      print result
    }')
    [[ -n "$dname" ]] && active_desktops["$dname"]="$idx"
  done < <(wmctrl -d)

  # selected is either a workspace name or a directory path.
  # Resolve: find workspace name by matching project_dir path.
  local ws_name=""
  local ws_project_dir=""
  if [[ "$selected" == /* ]]; then
    # Path — find workspace that owns this path (or parent)
    local resolved
    resolved=$(realpath -s "$selected" 2>/dev/null || printf '%s' "$selected")
    resolved="${resolved%/}"
    for ws in "$WORKSPACE_DIR"/*/; do
      [[ -d "$ws" ]] || continue
      [[ -f "$ws/project_dir" ]] || continue
      local pd
      pd=$(<"$ws/project_dir")
      pd="${pd%/}"
      if [[ "$resolved" == "$pd" ]]; then
        ws_name=$(basename "$ws")
        ws_project_dir="$pd"
        break
      fi
    done
  else
    ws_name="$selected"
    local ws_dir="$WORKSPACE_DIR/$ws_name"
    if [[ -f "$ws_dir/project_dir" ]]; then
      ws_project_dir=$(<"$ws_dir/project_dir")
    fi
  fi

  case "$action" in
    select|custom_input)
      if [[ -n "$ws_name" ]] && [[ -n "${active_desktops[$ws_name]+x}" ]]; then
        # Active workspace — switch to it
        wmctrl -s "${active_desktops[$ws_name]}"
        if [[ -n "$restore_wid" ]]; then
          wmctrl -i -a "$restore_wid"
        fi
      elif [[ -n "$ws_name" ]] && [[ -d "$WORKSPACE_DIR/$ws_name" ]]; then
        # Saved workspace — activate it
        if [[ -n "$ws_project_dir" ]]; then
          cmd_create "$ws_project_dir" "$ws_name"
        else
          echo "Error: no project_dir for workspace '$ws_name'" >&2
          return 1
        fi
      elif [[ -d "${selected%/}" ]]; then
        # Directory path — create new workspace
        cmd_create "${selected%/}"
      else
        echo "Error: '$selected' is neither a known workspace nor an existing directory" >&2
        return 1
      fi
      ;;
    close)
      if [[ -n "$ws_name" ]] && [[ -d "$WORKSPACE_DIR/$ws_name" ]]; then
        cmd_close "$ws_name"
      else
        echo "Error: workspace for '$selected' not found" >&2
        return 1
      fi
      ;;
  esac
}

cmd_menu() {
  local socket_path="/tmp/workspace-menu"

  local response
  response=$(echo "show $_START_MS" | socat -t999 STDIO UNIX-CONNECT:"$socket_path",shut-none 2>/dev/null)

  if [[ $? -ne 0 ]]; then
    echo "workspace-menu: daemon not running" >&2
    return 1
  fi

  [[ -z "$response" ]] && return 0

  cmd_handle_response "$response"
}

case "${1:-help}" in
  create)           shift; cmd_create "$@" ;;
  save)             shift; cmd_save "$@" ;;
  close)            shift; cmd_close "$@" ;;
  pin)              cmd_pin ;;
  list)             cmd_list ;;
  menu)             cmd_menu ;;
  handle-response)  shift; cmd_handle_response "$@" ;;
  help|*)
    echo "Usage:"
    echo "  workspace create <path> [name]           — create or switch to workspace"
    echo "  workspace save [name]                    — save Floorp tabs for current workspace"
    echo "  workspace close [name]                   — save tabs and remove workspace"
    echo "  workspace pin                            — pin focused Floorp window to all desktops"
    echo "  workspace list                           — list saved workspaces"
    echo "  workspace menu                           — rofi popup to switch/create/close workspaces"
    echo "  workspace handle-response \"<response>\"   — handle daemon menu response"
    ;;
esac
